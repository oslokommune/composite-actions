name: "Package and upload artifact"
description: >
  Packages Docker images or files/folders per environment using data from a JSON
  config: docker sources are pushed to ECR for later Terraform-driven ECS deploys,
  while file/folder sources are zipped if needed and uploaded to S3 for a Lambda +
  CloudFront deployment flow. Each environment entry (e.g. dev/prod) in the config
  carries its AWS account, bucket, role, and repository metadata so the action can
  iterate over every defined target.
inputs:
  config:
    description: "JSON-encoded config (.gp.cicd.json)"
    required: true
  tag:
    description: "The main tag to apply to the artifact"
    required: true
  source-location:
    description: "A Docker image ID, file or folder"
    required: true
  source-type:
    description: "docker-image | file | folder"
    required: true

outputs:
  result:
    description: The final tag value
    value: ${{ steps.upload.outputs.tag }}

runs:
  using: composite
  steps:
    - name: Configure AWS credentials in dev
      if: ${{ fromJSON(inputs.config).dev != null }}
      id: aws-credentials-dev
      uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 # v5.1.0
      with:
        aws-region: ${{ fromJSON(inputs.config).dev.defaultRegion }}
        role-to-assume: ${{ fromJSON(inputs.config).dev.artifactRoleArn }}
        output-env-credentials: false
        output-credentials: true

    - name: Configure AWS credentials in prod
      if: ${{ fromJSON(inputs.config).prod != null }}
      id: aws-credentials-prod
      uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 # v5.1.0
      with:
        aws-region: ${{ fromJSON(inputs.config).prod.defaultRegion }}
        role-to-assume: ${{ fromJSON(inputs.config).prod.artifactRoleArn }}
        output-env-credentials: false
        output-credentials: true

    - name: Package and upload artifact
      shell: bash --noprofile --norc -euo pipefail {0}
      id: upload
      env:
        AWSCREDS: |
          [profile dev]
          aws_access_key_id=${{ steps.aws-credentials-dev.outputs.aws-access-key-id }}
          aws_secret_access_key=${{ steps.aws-credentials-dev.outputs.aws-secret-access-key }}
          aws_session_token=${{ steps.aws-credentials-dev.outputs.aws-session-token }}

          [profile prod]
          aws_access_key_id=${{ steps.aws-credentials-prod.outputs.aws-access-key-id }}
          aws_secret_access_key=${{ steps.aws-credentials-prod.outputs.aws-secret-access-key }}
          aws_session_token=${{ steps.aws-credentials-prod.outputs.aws-session-token }}
        TZ: "Europe/Oslo"
        CONFIG: ${{ inputs.config }}
        PARTIAL_WORKFLOW_DISPATCH_URL: "${{ github.server_url}}/${{ github.repository }}/actions/workflows"
        SOURCE_TYPE: ${{ inputs.source-type }}
        SOURCE_LOCATION: ${{ inputs.source-location }}
        TAG: ${{ inputs.tag }}
      run: package-and-upload-artifact/package_and_upload.sh
    - name: Store artifact tag in commit status
      shell: bash --noprofile --norc -euo pipefail {0}
      env:
        COMMIT_SHA: ${{ github.sha }}
        GH_TOKEN: ${{ github.token }}
        DESCRIPTION: ${{ steps.upload.outputs.tag }}
        WORKFLOW: ${{ github.workflow }}
        TARGET_URL: "${{ github.server_url}}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
      run: |
        gh api "repos/${GITHUB_REPOSITORY}/statuses/${COMMIT_SHA}" \
          -f state="success" \
          -f context="$WORKFLOW / artifact-tag" \
          -f target_url="$TARGET_URL" \
          -f description="$DESCRIPTION"
