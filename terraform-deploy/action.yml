name: "Terraform apply"
description: Deploy application through infrastructure
inputs:
  config:
    description: "JSON-encoded config (.gp.cicd.json)"
    required: true
  stack-dir:
    required: true
    description: "The path to the application stack (e.g., `stacks/dev/app-km`)"
  environment:
    required: true
    description: "The type of environment (e.g. `dev`, `prod`). Must match environment in configuration file .gp.cicd.json."
  tag:
    required: false
    default: ""
    description: "The tag of an artifact to deploy"
  target-repository:
    description: "The name of the repository (e.g., `pirates-iac`) to checkout code from. Leave empty to skip checkout and use the current repository."
    required: false
    default: ${{ github.event.repository.name }}
  github-app-id:
    description: "ID of GitHub App used to get read access to the repository containing IaC"
    required: false
  github-app-private-key:
    description: "Private key of GitHub App used to get read access to the repository containing IaC"
    required: false
  github-deploy-key:
    description: "Repository deploy key that grants read access to shared libraries (e.g., golden-path-iac)"
    required: true
  send-deployment-event:
    description: "Whether to send an event to Datadog after successful deployment. By default this is only sent on default branch deployments, and it requires 'tag' to be set."
    default: "${{ github.event_name == 'push' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch) }}"
    required: false
  cancel-if-stale:
    description: "Whether to cancel the workflow if a newer run has already progressed further than the current run."
    default: "true"
    required: false
  datadog-api-key:
    description: "Datadog API key for sending deployment events"
    required: false

outputs:
  # NOTE: A composite action can't have dynamic outputs, so
  # we dump everything into a JSON-encoded string instead
  terraform-outputs:
    description: JSON-encoded Terraform outputs
    value: ${{ steps.apply.outputs.result }}

runs:
  using: composite
  steps:
    - name: "Notify about manual trigger"
      # Deploying a custom tag is outside the normal flow. Outputting that a custom tag is intended to be deployed will
      # help potential future debugging efforts.
      if: ${{ github.event.inputs.artifact-tag != ''}}
      shell: bash --noprofile --norc -euo pipefail {0}
      env:
        ARTIFACT_TAG: ${{ github.event.inputs.artifact-tag }}
        ENVIRONMENT: ${{ inputs.environment }}
      run: |
        echo "::notice title=Deploy to $ENVIRONMENT::Deployment was manually triggered with the artifact tag: $ARTIFACT_TAG"

    - name: Cancel if stale
      # NOTE: We only check on default branch as this is the only place where production deployments happen.
      # Probably OK to ignore workflow reruns as it requires explicit user action?
      if: ${{ inputs.cancel-if-stale == 'true' && github.run_attempt == 1 && github.ref == format('refs/heads/{0}', github.event.repository.default_branch) }}
      id: detect-stale-job
      uses: oslokommune/composite-actions/detect-stale-job@dda43bd11d1da1f9c9901bb82f152059c009ba49 # detect-stale-job-v1.0.1

    - name: Get stack directory
      id: get-stack-dir
      shell: bash --noprofile --norc -euo pipefail {0}
      env:
        EVENT_REPO: ${{ github.event.repository.name }}
        REPO: ${{ inputs.target-repository }}
        STACK_DIR: ${{ inputs.stack-dir }}
      run: |
        echo Get stack directory

        if [[ "${REPO}" == "${EVENT_REPO}" ]]; then
          echo "stack-dir=$STACK_DIR" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        checkout_path="tf-checkout-$(date +%s)"
        full_dir="$checkout_path/$STACK_DIR"

        echo "checkout-path=$checkout_path" >> "$GITHUB_OUTPUT"
        echo "stack-dir=$full_dir" >> "$GITHUB_OUTPUT"

    - name: Get GitHub App token
      if: inputs.target-repository != github.event.repository.name
      uses: actions/create-github-app-token@67018539274d69449ef7c02e8e71183d1719ab42 # v2.1.4
      id: get-token
      with:
        app-id: ${{ inputs.github-app-id }}
        private-key: ${{ inputs.github-app-private-key }}
        owner: ${{ github.repository_owner }}
        repositories: ${{ inputs.target-repository }}

    - name: Checkout
      if: inputs.target-repository != github.event.repository.name
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      id: checkout
      with:
        repository: "${{ github.repository_owner }}/${{ inputs.target-repository }}"
        token: "${{ steps.get-token.outputs.token }}"
        path: "${{ steps.get-stack-dir.outputs.checkout-path }}"
        fetch-depth: 1

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@61815dcd50bd041e203e49132bacad1fd04d2708 # v5.1.1
      with:
        aws-region: ${{ fromJSON(inputs.config)[inputs.environment].defaultRegion }}
        role-to-assume: ${{ fromJSON(inputs.config)[inputs.environment].deploymentRoleArn }}

    - name: Load golden-path-iac SSH deploy key
      uses: webfactory/ssh-agent@a6f90b1f127823b31d4d4a8d96047790581349bd # v0.9.1
      with:
        ssh-private-key: ${{ inputs.github-deploy-key }}

    - name: Extract Terraform version
      id: v
      shell: bash --noprofile --norc -euo pipefail {0}
      working-directory: ${{ steps.get-stack-dir.outputs.stack-dir }}
      run: |
        echo Extract Terraform version
        pwd
        ls -lah
        echo "TERRAFORM_VERSION=$(grep required_version *.tf | sed -E 's/[^"]+"([^"]+)"+/\1/')" >> "$GITHUB_OUTPUT"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3.1.2
      with:
        terraform_version: ${{ steps.v.outputs.TERRAFORM_VERSION }}

    - name: Initialize the working directory containing Terraform configuration files
      id: init
      shell: bash --noprofile --norc -euo pipefail {0}
      working-directory: ${{ steps.get-stack-dir.outputs.stack-dir }}
      continue-on-error: true
      run: |
        terraform init -input=false

    - name: Verify that latest code is checked out
      if: inputs.target-repository != github.event.repository.name
      shell: bash --noprofile --norc -euo pipefail {0}
      env:
        GH_TOKEN: ${{ steps.get-token.outputs.token }}
        LOCAL_SHA: ${{ steps.checkout.outputs.commit }}
        REPOSITORY_OWNER: ${{ github.repository_owner }}
        TARGET_REPOSITORY: ${{ inputs.target-repository }}
      run: |
        remote_sha="$(gh api repos/$REPOSITORY_OWNER/$TARGET_REPOSITORY/commits/HEAD --jq '.sha')"
        if [ "$LOCAL_SHA" != "$remote_sha" ]; then
          echo "Error: New commits detected after checkout"
          echo "Checked out: $LOCAL_SHA"
          echo "Latest: $remote_sha"
          echo
          echo "Solution: Trigger workflow again."
          exit 1
        fi
        echo "Verified: checked out SHA matches latest commit ($LOCAL_SHA)"

    - name: Update SSM parameter
      if: >-
        ${{
          steps.init.outcome == 'success' &&
          inputs.tag
        }}
      shell: bash --noprofile --norc -euo pipefail {0}
      env:
        TAG: ${{ inputs.tag }}
        STACK_DIR: ${{ inputs.stack-dir }}
        ENVIRONMENT_NAME: ${{ fromJSON(inputs.config)[inputs.environment].name }}
      run: |
        stack_name="$(basename "$STACK_DIR")"
        parameter_name="/$ENVIRONMENT_NAME/artifacts/$stack_name"
        aws ssm put-parameter \
          --name "$parameter_name" \
          --value "$TAG" \
          --type "String" \
          --overwrite

    - name: Apply the Terraform code
      id: apply
      if: steps.init.outcome == 'success'
      shell: bash --noprofile --norc -euo pipefail {0}
      working-directory: ${{ steps.get-stack-dir.outputs.stack-dir }}
      run: |
        terraform apply -auto-approve -lock-timeout=5m
        result="$(terraform output -json \
          | jq -c 'with_entries(select(.value.sensitive == false) | .value = .value.value)'
        )"
        echo "result=$result" >> "$GITHUB_OUTPUT"

    - name: Send deployment metric to Datadog
      if: ${{ always() && inputs.send-deployment-event == 'true' && inputs.datadog-api-key != '' }}
      shell: bash --noprofile --norc -euo pipefail {0}
      continue-on-error: true
      env:
        DD_API_KEY: ${{ inputs.datadog-api-key }}
        ENVIRONMENT: ${{ inputs.environment }}
        TAG: ${{ inputs.tag }}
        STACK_DIR: ${{ inputs.stack-dir }}
        APPLY_OUTCOME: ${{ steps.apply.outcome }}
        # Check if this was an automerged Renovate PR
        # that updates Boilerplate templates
        AUTOMERGED: ${{ github.actor == 'kjoremiljo-renovate[bot]' && contains(github.event.head_commit.message, 'update boilerplate templates') }}
      run: |
        timestamp="$(date +%s)"

        if [ -n "$TAG" ]; then
          deployment_type="app"
        else
          deployment_type="iac"
        fi

        if [ "$APPLY_OUTCOME" = "success" ]; then
          success="true"
        else
          success="false"
        fi

        stack_name="$(basename "$STACK_DIR")"

        curl -sS -X POST "https://api.datadoghq.eu/api/v1/series" \
          -H "Content-Type: application/json" \
          -H "DD-API-KEY: $DD_API_KEY" \
          -d @- <<EOF
        {
          "series": [
            {
              "metric": "utviklerflyt.golden_path.terraform.deploy",
              "type": "count",
              "points": [[$timestamp, 1]],
              "tags": [
                "deployment_type:$deployment_type",
                "success:$success",
                "environment:$ENVIRONMENT",
                "stack:$stack_name",
                "repo:$GITHUB_REPOSITORY",
                "workflow:$GITHUB_WORKFLOW",
                "branch:$GITHUB_REF_NAME",
                "event:$GITHUB_EVENT_NAME",
                "automerged:$AUTOMERGED",
                "env:utviklerflyt"
              ]
            }
          ]
        }
        EOF

    - name: Send deployment event to Datadog
      if: ${{ inputs.send-deployment-event == 'true' && inputs.tag != '' }}
      shell: bash --noprofile --norc -euo pipefail {0}
      # Probably don't want to halt deployments due to issues with deployment events
      continue-on-error: true
      env:
        ENVIRONMENT: ${{ inputs.environment }}
        VERSION: ${{ inputs.tag }}
        STACK_DIR: ${{ inputs.stack-dir }}
        GITHUB_TOKEN: ${{ github.token }}
        DD_API_KEY: ${{ inputs.datadog-api-key }}
      run: |
        started_at="$(gh run view --attempt "$GITHUB_RUN_ATTEMPT" "$GITHUB_RUN_ID" --json startedAt --jq '.startedAt | fromdate')"
        finished_at="$(date -u +%s)"
        service="${DD_SERVICE:-}"
        if [ "$service" = "" ]; then
          # Use stack name as fallback of DD_SERVICE not set
          service="$(basename "$STACK_DIR")"
        fi
        # Allow overwriting Datadog environment through DD_ENV
        env="${DD_ENV:-$ENVIRONMENT}"
        curl -X POST "https://api.datadoghq.eu/api/v2/dora/deployment" \
          -H "Accept: application/json" \
          -H "Content-Type: application/json" \
          -H "DD-API-KEY: ${DD_API_KEY}" \
          -d @- << EOF
        {
          "data": {
            "attributes": {
              "started_at": $started_at,
              "finished_at": $finished_at,
              "git": {
                "commit_sha": "$GITHUB_SHA",
                "repository_url": "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY"
              },
              "service": "$service",
              "env": "$env",
              "team": "${DD_TEAM:-n/a}",
              "version": "$VERSION"
            }
          }
        }
        EOF

    - name: Fail job if terraform apply failed or didn't run
      if: steps.apply.outcome != 'success'
      shell: bash --noprofile --norc -euo pipefail {0}
      run: |
        exit 1
