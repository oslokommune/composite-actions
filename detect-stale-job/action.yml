name: Detect stale job
description: Detect if a newer workflow run already has run the current job - making the current run stale. The job needs 'write' permissions to 'actions' in order to cancel a run.

inputs:
  cancel-if-stale:
    description: "Whether to cancel the workflow if a newer run has already progressed further than the current run, or just output the status."
    default: "true"
    required: false

outputs:
  is-stale:
    description: Whether the job was detected as stale
    value: ${{ steps.stale.outputs.is-stale == 'true' }}

runs:
  using: composite
  steps:
    - name: Cancel if stale
      shell: bash --noprofile --norc -euo pipefail {0}
      env:
        GITHUB_TOKEN: ${{ github.token }}
        CHECK_RUN_ID: ${{ job.check_run_id }}
        CANCEL_IF_STALE: ${{ inputs.cancel-if-stale }}
      id: stale
      run: |
        current_sha="$GITHUB_SHA"
        current_run_id="$GITHUB_RUN_ID"

        # Get current job details
        current_job_details="$(gh run view --repo "$GITHUB_REPOSITORY" "$GITHUB_RUN_ID" --json jobs | jq --argjson check_run_id "$CHECK_RUN_ID" '.jobs[] | select(.databaseId == $check_run_id)')"
        current_job_name="$(echo "$current_job_details" | jq --exit-status --raw-output '.name')"
        current_job_started_at="$(echo "$current_job_details" | jq --exit-status --raw-output '.startedAt')"

        echo "Current SHA: $current_sha"
        echo "Current run ID: $current_run_id"
        echo "Current job: $current_job_name"
        echo "Current job started at: $current_job_started_at"
        echo ""

        # NOTE: Run numbers are not guaranteed to be in order of commits, but it should be
        # good enough for most cases. For better accuracy, we could use something like:
        #   git merge-base --is-ancestor "$GITHUB_SHA" "$SHA_OF_POTENTIAL_DESCENDANT"
        # but that would require fetching git history, which may be slow.

        # Get list of workflow runs for current workflow on current branch with a run number greater than the current run
        runs="$(gh run list \
          --repo "$GITHUB_REPOSITORY" \
          --workflow "$GITHUB_WORKFLOW" \
          --branch "$GITHUB_REF_NAME" \
          --json "databaseId,number" \
          --limit 20 \
          | jq --raw-output --argjson current_run_number "$GITHUB_RUN_NUMBER" '.[] | select(.number > $current_run_number) | .databaseId')"

        if [ "$runs" == "" ]; then
          echo "No newer runs found - current run is up to date"
          exit 0
        fi

        echo "Checking if any newer runs have progressed further than the current run:"
        echo "$runs"
        echo ""

        # NOTE: The reason we don't just cancel based on the presence of a newer run is that
        # the newer run may not actually be ahead of the current run - it may be queued, or it might
        # be in progress but haven't made its way to the current job yet. In which case,
        # we are not out of order and would be cancelling unnecessarily, which can lead to a subpar DX:
        # 1. Run A starts, reaches "Deploy" job, gets concurrency lock and wait for manual approval.
        # 2. Run B starts, Run A is still waiting for approval, Run B reaches job "Deploy" and is queued behind run A.
        # 3. Run A is approved, but gets cancelled immediately because Run B is newer.

        while read -r run_id; do
          if [ "$run_id" == "" ]; then
            continue
          fi

          # NOTE: Checking if the newer run has reached or passed the job, making the current run out-of-order.
          # We look for a newer job that is in progress, or completed and has run at least one step (i.e. not skipped).
          newer_run_jobs="$(gh run view --repo "$GITHUB_REPOSITORY" "$run_id" --json jobs)"
          echo "Jobs in $run_id:"
          echo "$newer_run_jobs"

          # TODO: Ensure that we find at MOST one matching job? Shouldn't really happen though unless different
          # jobs use the same name
          newer_job_started_at="$(echo "$newer_run_jobs" \
            | jq --raw-output --arg job_name "$current_job_name" '.jobs[] | select(.name == $job_name and (.status == "in_progress" or (.status == "completed" and .steps != []))) | .startedAt')"

          if [ "$newer_job_started_at" == "" ]; then
            # No matching job found in the run
            continue
          fi

          if [[ "$newer_job_started_at" < "$current_job_started_at" ]]; then
            echo ""
            echo "Current run $current_run_id started job $current_job_name at $current_job_started_at, but a newer run with ID $run_id already started at $newer_job_started_at" >&2
            if [ "$CANCEL_IF_STALE" == "true" ]; then
              echo "Cancelling current run as it is stale" >&2
              # There's a --force flag we could use here as well
              gh run cancel --repo "$GITHUB_REPOSITORY" "$GITHUB_RUN_ID"
              echo "::error title=$current_job_name::Canceling to prevent out of order deployment"
              # Need non-zero exit here to ensure the run does not progress further as cancellation does not take effect immediately.
              exit 1
            fi
            echo "::warning title=$current_job_name::Detected out of order deployment"
            echo "is-stale=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        done <<< "$runs"

        echo "Current run is not stale - proceeding"
